{"version":3,"sources":["components/Audio/index.tsx","app/App.tsx","reportWebVitals.ts","index.tsx","components/Audio/styles.module.scss"],"names":["AudioPlayground","useState","audioSrc","setAudioSrc","audioType","setAudioType","recordingStatus","setRecordingStatus","audioContext","setAudioContext","recorder","setRecorder","audioData","setAudioData","samples","audioEl","useRef","canvasEl","initRecorder","a","device","navigator","mediaDevices","getUserMedia","audio","stream","MediaRecorder","AudioContext","startRecording","undefined","console","error","ondataavailable","e","state","items","push","data","blob","Blob","type","URL","createObjectURL","log","arrayBuffer","then","decodeAudioData","audioBuffer","initAudioBuffer","start","buffer","rawData","getChannelData","blockSize","Math","floor","length","filteredData","i","blockStart","sum","j","abs","setTimeout","draw","current","canvas","dpr","window","devicePixelRatio","width","offsetWidth","height","offsetHeight","padding","ctx","getContext","scale","translate","multiplier","pow","max","map","n","normalizeData","x","drawLineSegment","y","isEven","lineWidth","strokeStyle","beginPath","moveTo","lineTo","arc","PI","stroke","onClick","pause","resume","stop","ref","controls","src","className","styles","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.d85ba217.chunk.js","sourcesContent":["import React, { useRef, useState } from 'react';\nimport styles from './styles.module.scss';\n\nexport const AudioPlayground = (): React.ReactElement => {\n  const [audioSrc, setAudioSrc] = useState<string | null>(null);\n  const [audioType, setAudioType] = useState<string | undefined>();\n  const [recordingStatus, setRecordingStatus] = useState<'recording' | 'paused' | 'stopped'>('stopped');\n  const [audioContext, setAudioContext] = useState<AudioContext>();\n  const [recorder, setRecorder] = useState<MediaRecorder>();\n  const [audioData, setAudioData] = useState<Array<number>>();\n  const [samples] = useState(100); // Number of samples we want to have in our final data set\n\n  const audioEl = useRef<HTMLAudioElement | null>(null);\n  const canvasEl = useRef<HTMLCanvasElement>(null);\n\n  const initRecorder = async () => {\n    const device = navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n\n    const stream = await device;\n    setRecorder(new MediaRecorder(stream));\n    setAudioContext(new AudioContext());\n  };\n\n  //region RECORDINGS\n  const startRecording = async () => {\n    setAudioSrc(null);\n    setAudioData(undefined);\n    if(!recorder) {\n      console.error('Recorder not init');\n      await initRecorder();\n      if(!recorder) {\n        return;\n      }\n    }\n\n    recorder.ondataavailable = e => {\n      if(recorder.state === 'inactive') {\n        const items: BlobPart[] = [];\n        items.push(e.data);\n        const blob = new Blob(items, { type: e.data.type });\n        setAudioSrc(URL.createObjectURL(blob));\n        setAudioType(e.data.type);\n\n        if(!audioContext) {\n          console.log('No AudioContext');\n          return;\n        }\n        // Create AudioBuffer from Blob\n        blob.arrayBuffer()\n          .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\n          .then(audioBuffer => {\n            console.log({ audioBuffer });\n            initAudioBuffer(audioBuffer);\n          });\n      }\n    };\n\n    console.log('START recording...');\n    recorder.start();\n    setRecordingStatus('recording');\n  };\n  const stopRecording = () => {\n    console.log('STOP recording...');\n    if(!recorder) {\n      return;\n    }\n    recorder.stop();\n    setRecordingStatus('stopped');\n  };\n  const pauseRecording = () => {\n    if(!recorder) {\n      return;\n    }\n    recorder.pause();\n    setRecordingStatus('paused');\n  };\n  const resumeRecording = () => {\n    if(!recorder) {\n      return;\n    }\n    recorder.resume();\n    setRecordingStatus('recording');\n  };\n  //endregion\n\n  //region AUDIO MANIPULATION\n  const initAudioBuffer = (buffer: AudioBuffer) => {\n    if(!buffer) {\n      console.error('No AudioBuffer');\n      return;\n    }\n    const rawData = buffer.getChannelData(0); // We only need to work with one channel of data\n    const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n    const filteredData: Array<number> = [];\n    for(let i = 0; i < samples; i++) {\n      let blockStart = blockSize * i; // the location of the first sample in the block\n      let sum = 0;\n      for(let j = 0; j < blockSize; j++) {\n        sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n      }\n      filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n    }\n    console.log({ filteredData });\n    setAudioData(filteredData);\n    setTimeout(() => draw(filteredData), 0);\n  };\n\n  const normalizeData = (filteredData: Array<number>) => {\n    const multiplier = Math.pow(Math.max(...filteredData), -1);\n    return filteredData.map(n => n * multiplier);\n  };\n\n  const draw = (data: Array<number> | undefined) => {\n\n    if(!canvasEl?.current) {\n      console.error('No canvas HTML element');\n      return;\n    }\n\n    if(!data) {\n      console.error('No audio data');\n      return;\n    }\n    // Set up the canvas\n    const canvas: HTMLCanvasElement = canvasEl.current;\n    const dpr = window.devicePixelRatio || 1;\n    const padding = 20;\n    canvas.width = canvas.offsetWidth * dpr;\n    canvas.height = (canvas.offsetHeight + padding * 2) * dpr;\n    const ctx = canvas.getContext('2d');\n    if(!ctx) {\n      console.error('No canvas context');\n      return;\n    }\n    ctx.scale(dpr, dpr);\n    ctx.translate(0, canvas.offsetHeight / 2 + padding); // Set Y = 0 to be in the middle of the canvas\n\n    // Normalize data if needed\n    data = normalizeData(data);\n\n    // draw the line segments\n    const width = canvas.offsetWidth / data.length;\n    for(let i = 0; i < data.length; i++) {\n      const x = width * i;\n      let height = data[i] * canvas.offsetHeight - padding;\n      if(height < 0) {\n        height = 0;\n      } else if(height > canvas.offsetHeight / 2) {\n        // height = height > canvas.offsetHeight / 2;\n        height = canvas.offsetHeight / 2;\n      }\n      drawLineSegment(ctx, x, height, width, !!((i + 1) % 2));\n    }\n  };\n\n  const drawLineSegment = (ctx: CanvasRenderingContext2D, x: number, y: number, width: number, isEven: boolean) => {\n    ctx.lineWidth = 1; // how thick the line is\n    ctx.strokeStyle = '#fff'; // what color our line is\n    ctx.beginPath();\n    y = isEven ? y : -y;\n    ctx.moveTo(x, 0);\n    ctx.lineTo(x, y);\n    ctx.arc(x + width / 2, y, width / 2, Math.PI, 0, isEven);\n    ctx.lineTo(x + width, 0);\n    ctx.stroke();\n  };\n  //region\n\n  // useEffect(() => {\n  //   initRecorder().then(() => console.log('Recorder initialized'));\n  // }, []);\n\n  return (\n    <div>\n      <h1>Welcome to Audio Browser API Playground</h1>\n\n      { !recorder && <button onClick={ initRecorder }>Activate recorder</button> }\n\n      { recorder &&\n        <div>\n\n          { recordingStatus === 'stopped' && <button onClick={ startRecording }>Rec</button> }\n\n          { recordingStatus === 'recording' && <button onClick={ pauseRecording }>Pause</button> }\n\n          { recordingStatus === 'paused' && <button onClick={ resumeRecording }>Resume</button> }\n\n          { (recordingStatus === 'recording' || recordingStatus === 'paused') &&\n            <button onClick={ stopRecording }>Stop</button> }\n          &nbsp;\n          <span> Status: { recordingStatus }</span>\n\n        </div>\n\n      }\n\n      {\n        audioSrc &&\n        <div>\n          <audio ref={ audioEl } controls>\n            <source src={ audioSrc } type={ audioType }/>\n          </audio>\n        </div>\n      }\n\n      { audioData && <canvas ref={ canvasEl } className={ styles.canvas }/> }\n\n    </div>\n  );\n};\n","import React from 'react';\n\nimport 'normalize.css'; // Note this\n\n// import { Provider } from 'react-redux';\n// import { store } from './App.store';\n// import { BrowserRouter, Route, Routes } from 'react-router-dom';\n// import { HomePage } from '../features/home/HomePage';\nimport { AudioPlayground } from '../components/Audio';\n\nfunction App() {\n  return (\n    <AudioPlayground/>\n    /*<Provider store={ store }>\n      <BrowserRouter>\n        <Routes>\n          <Route path=\"\" element={ <HomePage/> }/>\n        </Routes>\n      </BrowserRouter>\n    </Provider>*/\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './app/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"canvas\":\"styles_canvas__2Mk7O\"};"],"sourceRoot":""}