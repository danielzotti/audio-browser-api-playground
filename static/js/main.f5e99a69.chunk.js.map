{"version":3,"sources":["components/Audio/styles.module.scss","features/counter/store/counter.actions.ts","features/counter/store/counter.reducers.ts","features/counter/store/counter.epics.ts","app/App.store.ts","components/Audio/index.tsx","app/App.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","increment","createAction","decrement","reset","initialState","value","counterReducer","createReducer","type","state","payload","counterEpics","action$","pipe","ofType","tap","console","log","ignoreElements","rootReducer","combineReducers","counter","rootEpic","combineEpics","epicMiddleware","createEpicMiddleware","store","configureStore","reducer","devTools","process","middleware","run","useSelector","AudioPlayground","useState","audioSrc","setAudioSrc","audioType","setAudioType","recordingStatus","setRecordingStatus","audioContext","setAudioContext","recorder","setRecorder","audioData","setAudioData","samples","audioEl","useRef","canvasEl","initRecorder","a","device","navigator","mediaDevices","getUserMedia","audio","stream","MediaRecorder","AudioContext","startRecording","undefined","error","onpause","res","onstop","stopMediaStream","onresume","onstart","ondataavailable","e","items","push","data","blob","Blob","URL","createObjectURL","arrayBuffer","then","decodeAudioData","audioBuffer","initAudioBuffer","start","tracks","getTracks","forEach","track","stop","buffer","rawData","getChannelData","blockSize","Math","floor","length","filteredData","i","blockStart","sum","j","abs","setTimeout","draw","current","canvas","width","offsetWidth","height","offsetHeight","padding","ctx","getContext","scale","translate","multiplier","pow","max","map","n","normalizeData","x","drawLineSegment","y","isEven","lineWidth","strokeStyle","beginPath","moveTo","lineTo","arc","PI","stroke","onClick","pause","resume","ref","controls","src","className","styles","App","basename","path","element","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f5e99a69.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"canvas\":\"styles_canvas__2Mk7O\"};","import { createAction } from '@reduxjs/toolkit';\n\nexport const increment = createAction<{ value: number }>('counter/increment');\nexport const decrement = createAction<{ value: number }>('counter/decrement');\nexport const reset = createAction('counter/reset');\n","import { createReducer } from '@reduxjs/toolkit';\nimport { decrement, increment, reset } from './counter.actions';\n\nexport interface CounterState {\n  value: number;\n}\n\nexport const initialState: CounterState = {\n  value: 0\n};\n\nexport const counterReducer = createReducer<CounterState>(initialState, {\n  [increment.type]: (state, { payload: { value } }) => ({ ...state, value: state.value + value }),\n  [decrement.type]: (state, { payload: { value } }) => ({ ...state, value: state.value - value }),\n  [reset.type]: (state) => ({ ...state, value: initialState.value }),\n});\n","import { Epic, ofType } from 'redux-observable';\nimport { ignoreElements, tap } from 'rxjs';\nimport { increment } from './counter.actions';\n\nexport const incrementEpic: Epic = action$ => action$.pipe(\n  ofType(increment.type),\n  tap(({ type, payload }) => console.log('This log is triggered only by increment action thanks to epics :)')),\n  ignoreElements() // This line prevents loop\n);\n\n\nexport const counterEpics = [incrementEpic];\n","import { combineReducers, configureStore } from '@reduxjs/toolkit';\nimport { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport { combineEpics, createEpicMiddleware } from 'redux-observable';\n\nimport { counterReducer } from '../features/counter/store/counter.reducers';\nimport { counterEpics } from '../features/counter/store/counter.epics';\n\nconst rootReducer = combineReducers({\n  counter: counterReducer\n});\n\nexport const rootEpic = combineEpics(\n  ...counterEpics,\n);\nconst epicMiddleware = createEpicMiddleware();\n\nexport const store = configureStore({\n  reducer: rootReducer,\n  devTools: process.env.NODE_ENV !== 'production',\n  middleware: [epicMiddleware]\n});\nepicMiddleware.run(rootEpic);\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<typeof store.getState>\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import React, { useRef, useState } from 'react';\nimport styles from './styles.module.scss';\n\nexport const AudioPlayground = (): React.ReactElement => {\n  const [audioSrc, setAudioSrc] = useState<string | null>(null);\n  const [audioType, setAudioType] = useState<string | undefined>();\n  const [recordingStatus, setRecordingStatus] = useState<'recording' | 'paused' | 'stopped'>('stopped');\n  const [audioContext, setAudioContext] = useState<AudioContext>();\n  const [recorder, setRecorder] = useState<MediaRecorder>();\n  const [audioData, setAudioData] = useState<Array<number>>();\n  const [samples] = useState(100); // Number of samples we want to have in our final data set\n\n  const audioEl = useRef<HTMLAudioElement | null>(null);\n  const canvasEl = useRef<HTMLCanvasElement>(null);\n\n  const initRecorder = async () => {\n    const device = navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n\n    const stream = await device;\n    setRecorder(new MediaRecorder(stream));\n    setAudioContext(new AudioContext());\n  };\n\n  //region RECORDINGS\n  const startRecording = async () => {\n    setAudioSrc(null);\n    setAudioData(undefined);\n    if(!recorder) {\n      console.error('Recorder not init');\n      return;\n    }\n\n    recorder.onpause = (res) => {\n      console.log('PAUSE recording...');\n      setRecordingStatus('paused');\n    };\n\n    recorder.onstop = (res) => {\n      console.log('STOP recording...');\n      setRecordingStatus('stopped');\n      stopMediaStream();\n    };\n\n    recorder.onresume = (res) => {\n      console.log('RESUME recording...');\n      setRecordingStatus('recording');\n    };\n\n    recorder.onstart = (res) => {\n      console.log('START recording...');\n      setRecordingStatus('recording');\n    };\n\n    recorder.ondataavailable = e => {\n      if(recorder.state === 'inactive') {\n        const items: BlobPart[] = [];\n        items.push(e.data);\n        const blob = new Blob(items, { type: e.data.type });\n        setAudioSrc(URL.createObjectURL(blob));\n        setAudioType(e.data.type);\n\n        if(!audioContext) {\n          console.log('No AudioContext');\n          return;\n        }\n        // Create AudioBuffer from Blob\n        blob.arrayBuffer()\n          .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\n          .then(audioBuffer => {\n            console.log({ audioBuffer });\n            initAudioBuffer(audioBuffer);\n          });\n      }\n    };\n    recorder.start();\n  };\n  const stopRecording = () => {\n    recorder?.stop();\n  };\n  const pauseRecording = () => {\n    recorder?.pause();\n  };\n  const resumeRecording = () => {\n    recorder?.resume();\n  };\n  const stopMediaStream = () => {\n    const tracks = recorder?.stream.getTracks();\n    console.log({ tracks });\n    tracks?.forEach((track) => track.stop());\n  };\n  //endregion\n\n  //region AUDIO MANIPULATION\n  const initAudioBuffer = (buffer: AudioBuffer) => {\n    if(!buffer) {\n      console.error('No AudioBuffer');\n      return;\n    }\n    const rawData = buffer.getChannelData(0); // We only need to work with one channel of data\n    const blockSize = Math.floor(rawData.length / samples); // the number of samples in each subdivision\n    const filteredData: Array<number> = [];\n    for(let i = 0; i < samples; i++) {\n      let blockStart = blockSize * i; // the location of the first sample in the block\n      let sum = 0;\n      for(let j = 0; j < blockSize; j++) {\n        sum = sum + Math.abs(rawData[blockStart + j]); // find the sum of all the samples in the block\n      }\n      filteredData.push(sum / blockSize); // divide the sum by the block size to get the average\n    }\n    console.log({ filteredData });\n    setAudioData(filteredData);\n    setTimeout(() => draw(filteredData), 0);\n  };\n  const normalizeData = (filteredData: Array<number>) => {\n    const multiplier = Math.pow(Math.max(...filteredData), -1);\n    return filteredData.map(n => n * multiplier);\n  };\n  const draw = (data: Array<number> | undefined) => {\n\n    if(!canvasEl?.current) {\n      console.error('No canvas HTML element');\n      return;\n    }\n\n    if(!data) {\n      console.error('No audio data');\n      return;\n    }\n\n    // Set up the canvas\n    const canvas: HTMLCanvasElement = canvasEl.current;\n    const dpr = 1; // OR window.devicePixelRatio\n    const padding = 20;\n    canvas.width = canvas.offsetWidth * dpr;\n    canvas.height = (canvas.offsetHeight + padding * 2) * dpr;\n    const ctx = canvas.getContext('2d');\n    if(!ctx) {\n      console.error('No canvas context');\n      return;\n    }\n    ctx.scale(dpr, dpr);\n    ctx.translate(0, canvas.offsetHeight / 2 + padding); // Set Y = 0 to be in the middle of the canvas\n\n    // Normalize data if needed\n    data = normalizeData(data);\n\n    // draw the line segments\n    const width = canvas.offsetWidth / data.length;\n    for(let i = 0; i < data.length; i++) {\n      const x = width * i;\n      let height = data[i] * canvas.offsetHeight - padding;\n      if(height < 0) {\n        height = 0;\n      } else if(height > canvas.offsetHeight / 2) {\n        // height = height > canvas.offsetHeight / 2;\n        height = canvas.offsetHeight / 2;\n      }\n      drawLineSegment(ctx, x, height, width, !!((i + 1) % 2));\n    }\n  };\n  const drawLineSegment = (ctx: CanvasRenderingContext2D, x: number, y: number, width: number, isEven: boolean) => {\n    ctx.lineWidth = 1; // how thick the line is\n    ctx.strokeStyle = '#fff'; // what color our line is\n    ctx.beginPath();\n    y = isEven ? y : -y;\n    ctx.moveTo(x, 0);\n    ctx.lineTo(x, y);\n    ctx.arc(x + width / 2, y, width / 2, Math.PI, 0, isEven);\n    ctx.lineTo(x + width, 0);\n    ctx.stroke();\n  };\n  //region\n\n  return (\n    <div>\n      <h1>Welcome to Audio Browser API Playground</h1>\n\n      { !recorder && <div>\n        <button onClick={ initRecorder }>Activate media streaming</button>\n      </div> }\n      { recorder && <div>\n        <button onClick={ stopMediaStream }>Deactivate media streaming</button>\n      </div> }\n\n      { recorder &&\n        <div>\n\n          { recordingStatus === 'stopped' && <button onClick={ startRecording }>Rec</button> }\n\n          { recordingStatus === 'recording' && <button onClick={ pauseRecording }>Pause</button> }\n\n          { recordingStatus === 'paused' && <button onClick={ resumeRecording }>Resume</button> }\n\n          { (recordingStatus === 'recording' || recordingStatus === 'paused') &&\n            <button onClick={ stopRecording }>Stop</button> }\n          &nbsp;\n          <span> Status: { recordingStatus }</span>\n\n        </div>\n\n      }\n\n      {\n        audioSrc &&\n        <div>\n          <audio ref={ audioEl } controls>\n            <source src={ audioSrc } type={ audioType }/>\n          </audio>\n        </div>\n      }\n\n      { audioData && <canvas ref={ canvasEl } className={ styles.canvas }/> }\n\n    </div>\n  );\n};\n","import React from 'react';\n\nimport 'normalize.css';\n\nimport { Provider } from 'react-redux';\nimport { store } from './App.store';\nimport { BrowserRouter, Route, Routes } from 'react-router-dom';\nimport { AudioPlayground } from '../components/Audio';\n\nfunction App() {\n  return (\n    <Provider store={ store }>\n      <BrowserRouter basename={ process.env.PUBLIC_URL }>\n        <Routes>\n          <Route path=\"/\" element={ <AudioPlayground/> }/>\n        </Routes>\n      </BrowserRouter>\n    </Provider>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './app/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}